.\" Process this file with
.\" groff -man -Tascii $FILENAME
.\"
.\"
.TH PCR-ORACLE "8" "@DATE@" "@PCR_ORACLE_VERSION@" "Predict TPM PCR values"
.SH NAME
pcr-oracle \- predict PCR values
.SH SYNOPSIS
.BR "pcr-oracle [\fIoptions\fP] \fIaction\fP ...
.\" ##################################################################
.\" # DESCRIPTION
.\" ##################################################################
.SH DESCRIPTION
This utility can be used to predict TPM PCR values at a specific time during
system boot, create a PCR policy for these values, and seal a secret to that.
.P
In simple prediction mode, \fPpcr-oracle\fP will compute expected
hash values for a subset of PCRs, and write them to standard
output. The most common use case will probably be to base the
prediction on the TPM event log that was generated by the firmware
during the most recent boot. However, there are other modes as well.
.P
In sealing mode, \fPpcr-oracle\fP will seal a given secret (such as a
LUKS device password) to either a set of PCR values, or to an authorized
PCR policy.
.\" ##################################################################
.\" # Prediction Mode
.\" ##################################################################
.SS Prediction Mode
In this mode, \fBpcr-oracle\fP is invoked like this:
.P
.nf
.in +2
# pcr-oracle --from eventlog \\
.br
        --before --stop-event grub-command=tpm2_key_protector_init \\
.br
        predict 0,2,4,7,9
.fi
.P
This would create a PCR prediction for registers 0, 2, 3, 7, and 9 by
scanning the current TPM event log until the point where grub executes
a command called \fBtpm2_key_protector_init\fP.
.P
As it processes the log, it will recompute the hash values for certain events to
match the latest changes that were made to the system. For instance, for EFI Boot
Variable events, it will consult the \fIcurrent\fP value of a EFI variable and
rehash it. The same holds for EFI Boot Service Application events for grub2 or
shim; or for EFI GPT events.
.P
In the example above, \fBpcr-oracle\fP will print the predicted values to standard
output. If you want to process these values with a tool from the tpm2.0-tools 
package, you may prefer binary output, which you can select by invoking the
tool with \fB--format binary\fP.
.\" ##################################################################
.\" # Authorized Policies
.\" ##################################################################
.SS Using Authorized Policies
The standard approach for sealing a secret against an expected system state
using the TPM is to create what is called a "PCR Policy". This policy essentially
requires a given set of PCRs to contain a specific set of values. This policy can
be used to "seal" a secret, ie encrypt it using a key only the TPM has access
to.
.P
At some point, for example during the boot process, the boot loader will
attempt to unseal this sealed secret. If the TPM's PCRs contain the
expected values at this point in time, unsealing will succeed. If they
do not contain the expected values, unsealing will either fail, or
produce gibberish.
.P
While this approach is sound and simple, it is not very flexible, unfortunately.
For example, transparently handling updates of the boot loader is rather
difficult because we would first have to retrieve the secret before we're able
to re-seal it to the future set of PCR values. This is where Authorized
Policies come in.
.P
TPM Authorized Policies provide a mechanism by which a secret is not sealed
to a set of specific PCR values, but to a list of PCR indices, and a public
RSA key. This combination (PCR indices and public key) are called an
Authorized Policy.
.P
The owner of the system can then use the secret RSA key to "authorize"
a specific set of PCR values, which is in essence a digital signature.
.P
When unsealing the secret during system boot, the boot loader would
present the TPM with the original Authorized Policy, and the signed set
of PCR values. The TPM then essentially compares the current set of PCR
values (as selected by the policy) to the authorized set of values, and
verify the authorization's signature using the public key from the
policy. If the PCR values match, and the signature checks out, it will
be able to unseal the secret.
.P
The benefit of this approach is that you can now seal the secret (such as
a LUKS password) once - and when we later update the boot loader, shim
loader etc, we just have to authorize the new set of PCR values using the
RSA secret key.
.P
So here's an example sequence of commands to use an authorized policy:
.P
.nf
.in +2
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --auth authorized.policy \\
.br
        create-authorized-policy 0,2,4,7,9
.br
# pcr-oracle \\
.br
        --auth authorized.policy \\
.br
        --input file-containing-secret \\
.br
        --output sealed-secret \\
.br
        seal-secret
.br
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --from eventlog \\
.br
        --before --stop-event grub-command=tpm2_key_protector_init \\
.br
        --output signed.policy \\
.br
        sign 0,2,4,7,9
.br
.fi
.P
The first of these commands creates the authorized policy and writes it
to a file named \fPauthorized.policy\fP. This file, along with the public
portion of the RSA key, needs to be stored somewhere in a location that
is accessible at the time we need to unlock the LUKS key.
.P
The second command seals the secret against this policy. The clear text
is stored in \fPfile-containing-secret\fP, the sealed cipher text is 
stored in \fBsealed-secret\fP. Note that the TPM is limited in the maximum
amount of secret data it can seal; it's probably safe to assume a limit of
128 bytes.
.P
Finally, the third command using the prediction logic of \fBpcr-oracle\fP
to predict a specific set of PCR values, in exactly the same way described
in the section above on prediction mode. It then uses the given RSA key
to sign these values and store the result in \fBsigned.policy\fP.
.P
Depending on the boot loader used, it may be helpful to provide the
public portion of the RSA key in a format that is trivial to handle. For
instance, it would be overkill to add DER parsing of RSA keys to grub.
In a case like that, you want the key to be available in a form that
can be fed to the TPM chip more or less directly. \fBpcr-oracle\fP
supports this via its \fBstore-public-key\fP subcommand:
.P
.nf
.in +2
# pcr-oracle \\
.br
        --private-key policy-key.pem \\
.br
        --public-key policy-pubkey \\
.br
        store-public-key
.fi
.P
This command will read the RSA private key from the PEM file,
and write the public key as a \fBTPM2B_PUBLIC\fP object to
the indicated output file \fBpolicy-pubkey\fP.
.\" ##################################################################
.\" # Test Cases
.\" ##################################################################
.SS Creating and Replaying Test Cases
Firmwares tend to be buggy, like every piece of code, and UEFI firmwares
are no different. In order to create a broad base of test cases to
validate \fBpcr-oracle\fP against, it comes with support for creating
and replaying test cases.
.P
A test case is mostly a dump of the data that \fBpcr-oracle\fP processes
when re-hashing the events from the TPM event log. This includes
the content of UEFI variables such as Boot entries, variables related
to Secure Boot, GPT headers, full copies of any EFI Applications loaded
during bootup (such as \fBshim.efi\fP, \fBgrub.efi\fP), and hashes
for other files loaded by the boot loader (such as \fBgrub.cfg\fP, or
the kernel and initrd).
.P
The following command will create a test case and store it in a
directory tree at \fB/tmp/pcr-oracle.test\fP:
.P
.nf
.in +2
# pcr-oracle --from eventlog --verify current -d \\
.br
        --create-testcase /tmp/pcr-oracle.test \\
.br
        predict all
.fi
.P
If you want to submit your test case, please use \fBtar\fP to archive
the test case and create an issue in the github issue tracker at 
\fBgithub.com/okirch/pcr-oracle\fP.
.P
To replay a test case, you can do this:
.P
.nf
.in +2
# pcr-oracle --from eventlog --verify current -d \\
.br
        --replay-testcase /tmp/pcr-oracle.test \\
.br
        predict all
.fi
.P
.\" ##################################################################
.\" # OPTIONS
.\" ##################################################################
.SH OPTIONS
.TP
.BI --from " source
In prediction mode, specify a source from which to initialize the PCRs. This
can be one of
.BR eventlog ,
.BR current ", or
.BR zero .
.IP
With \fBeventlog\fP, the tool scans the TPM event log and re-compute
the event hashes based on the current state of the system.
.IP
Specifying a source of \fBzero\fP will start prediction with all PCRs cleared.
Specifying a source of \fBcurrent\fP will start prediction with all PCRs
set to the current values of the system's TPM.
.TP
.BI --algorithm " hash-alg
By default, \fBpcr-oracle\fP will operate on PCR registers that use  the
sha256 hash algorithm. Using this option, you can select a different hash
algorithm, assuming the chip supports it. 
For backward compatibility with version 1 of the specification, all TPMv2
chips also support sha1, but using that is not recommended.
.TP
.BI --format " fmt
In prediction mode, \fBpcr-oracle\fP will write the predicted PCR values
to standard output in a human readable format. Using this option, you can
select different output formats.
.IP
A format of \fBbinary\fP will write the predicted values as a binary octet
stream, all values concatenated together. This format can be used with
tools like 
.BR tpm2_policypcr (1). A format of \fBtpm2-tools\fP will use a reporting
format this is similar to the one that the tpm2-tools produce as output.
The default behavior is selected by format \fBplain\fP.
.TP
.BI --stop-event " event-desc
Specify at which point to stop processing the TPM event log, and report
the predicted PCR values. The format of \fIevent-desc\fP is an event type,
followed by a \fB=\fP, followed by a string argument.
.IP
Currently, only two event types are supported, \fBgrub-command\fP and
\fBgrub-file\fP. These correspond to the IPL event emitted by grub
when executing a command, or reading a file, respectively.
.IP
For a grub command event, the string argument is the name of the command,
without any arguments. For a grub file event, the string argument is
a file name or a (partial) file path. Path tail matching is performed,
i.e. an event for reading \fBEFI/BOOT/grub.cfg\fP can be matched by specifying
a stop event for \fBgrub.cfg\fP, \fBBOOT/grub.cfg\fP, or \fBEFI/BOOT/grub.cfg\fP,
respectively.
.TP
.BI --before
When a stop event has been given, report predicted PCR values \fIbefore\fP
processing the event. This is the default behavior.
.TP
.BI --after
When a stop event has been given, report predicted PCR values \fIafter\fP
processing the event. This may be useful, for example, if you don't
measure grub's command events (tracked in PCR8) but only its file load
events (tracked in PCR9). In this case, it would be totally sufficient
to stop processing after grub loaded \fPgrub.cfg\fP from the EFI
System Partition.
.TP
.BI --authorized-policy " path
Specify the location of the authorized policy. In conjunction with
the \fBcreate-authorized-policy\fP action, the newly created policy
is written to this location. For subsequent actions, such as \fBseal\fB,
the policy will be read from this location.
.TP
.BI --private-key " path
Specify the RSA secret key to be used with authorized policies.
.TP
.BI --public-key " path
Specify an RSA public key to be used with authorized policies.
.TP
.BI --tpm-eventlog " path
By default, the tool will read the current TPM event log. It is possible
to process an event log generated on a different system by specifying it
with this option.
.SH NOTES
\fBpcr-oracle\fP also supports an \fBunseal\fP action for unsealing
secrets. This is mostly for testing purposes and may change at any
time.
.SH SEE ALSO
.BR tpm2_policypcr (1),
.BR tpm2_policyauthorize (1),
.BR tpm2_create (1).
.SH AUTHOR
\fBpcr-oracle\fP was written by Olaf Kirch.
